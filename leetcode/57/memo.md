# Step 1

## 走査 + 新しいリスト作成

少し、入力リストを改変する方法を考え、悩んだが、問題文に新しいリストを作っていいとの言及があることに気づき、そこからはすぐにテストケースをパスする回答を書けた。

手作業だったらどうやるか考え、シンプルに最初からintervalを見ていって、新しく挿入するintervalを区間がかぶる場合は合体させ、そうでないならそのまま新しいリストに入れていけばいいな、と考えた。

時間計算量: O(n), 空間計算量: O(n)

## 再帰 - 1

intervalを一つずつ走査はループでも表せるなと思ったのでざっと書いてみる -> `step1_recursive_1.py`

時間計算量: O(n^2), 各intervalに対してintervals[1:]で新しいリストを作成している。
空間計算量: O(n^2), call stackの長さがnで、各フレームでintervals[1:]のスライスも保持している (n-1 + n-2 + ... + 1 = O(n^2))。

とりあえず書いてから、少し考えて、インデックスのみを渡せば新しいリストの作成をせずに済むな、と思った。

## 再帰 - 2

インデックスをhelper関数に渡すことで、スライシングによる新たなリスト作成の手間が省けた。

時間計算量: O(n), 多くても入力リストの長さ (n) + newInterval挿入 (1) 回の再帰。
空間計算量: O(n), call stack, 答え保存用のリスト
