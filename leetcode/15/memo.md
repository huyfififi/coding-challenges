# Step 1

素直に問題を分割すると、三つの値のうち一番左のものを固定して[Two Sum](https://leetcode.com/problems/two-sum/description/)をする方法が思いつく。

## Two Sum - Hash Mapを使用した解法の応用 -> `step1_two_sum_seen_tle.py`

Two Sumで真っ先に思い出したのは、出会った値をhash mapに入れていって、(target - 今見ている値) がhash mapに存在している (既に出会っている) ならば、その値と今見ている値 (のインデックス) を返せばいい、という方法だった。

今回の問題では、インデックスのことは考えなくても良いので、`dict`ではなく`set`でいいなと考えた。また、

> Notice that the solution set must not contain duplicate triplets.

という制約があるので、3つの値の組みをソート -> `tuple`に変換 -> `set`に登録をすることで、被りを回避した。

時間計算量: O(n^2)
空間計算量: O(n)

しかし、この解法ではTLEとなった。Sort + Two Pointers の解法ではテストケースをパスしているのを見ると、

```python
# step1_two_sum_seen_tle.py
answer.add(tuple(sorted([fixed_number, number, complement])))
# step1_two_sum_sort.py
answer.add((fixed_number, left_number, right_number))
```

`3 <= nums.length <= 3000`なので、全部で計算ステップが `(n - 1) + (n - 2) + ... + 1  = n(n - 1)/2 ~= 3000 * 3000 / 2 = 4.5 * 10 ^ 6`。
リスト作成 + ソート + タプル作成 (全ての値が0の場合ほぼ毎回)、ハッシュテーブルへの検索・追加、がそれだけの数実行される (定数倍でかかってくる) ので実行時間が長くなりTLEになるのだろう。

## Two Sum - Sorting + Two Pointersを使用した解法の応用 -> `step1_two_sum_sort.py`

時間計算量: O(n^2)
空間計算量: O(n)

# Step 2

(Step 2に進む時点では) Discord内に前例は見つからなかった。LeetCodeのSolutionsをざっと眺めてみる。
ざっと眺めてみると、やはり最初の値を固定して、Sorting + Two Pointersに持ち込む解法が一番多かった。あとは、言われれば確かに動くトリッキーな解法がいくつかあったが、理解に時間がかかり、説明するのに苦労する解法を深掘りするのはやめておこう。

私は、Step 1では被りを避ける処理に`set[tuple]`を用いたが、素直にポインタを動かして被りをスキップする方法の方が、余計な疑問を生まないし (なぜ`set`を使用しているのか？など)、型の変換処理、`set`に入れるためのハッシュ化処理が必要なくなるので、そちらの方が良いなと思った。

また、ソートをする解法で、一つ目の値が正の場合、二つ目・三つ目はそれ以上になるので、早めに走査を打ち切ってもいい、などの枝刈りをしていなかったなと気づいた。私は多少余計な計算をしても、条件分岐をシンプルにしたいが、どちらが良いかな。

## 少し迷ったところ

### 副作用がない形にするとうまくコードがまとまらない。

```
nums = sorted(nums)
```

としてしまうと、コードの途中で`nums`がオリジナルのものか、新しく作成したソート後のものなのかわかりづらい。副作用も出てしまう。しかし、

```
sorted_nums = sorted(nums)
```

と別の変数を置くと、コードを書いている時にどちらを使うべきなのか混乱しがちで、実際に`sorted_nums[i]`とするべきところを`nums[i]`としてしまってバグを起こしてしまうことが何回かあった。悩みどころだ。

### `nums[left]`, `nums[right]`, `len(nums)`に名前をつけるか迷った

一つのループ内で複数回登場するので、名前を置いても良いかなと思っていたが、逆に行数が増えて読みにくくなるような感覚があったのでそのまま`nums[left]`、`nums[right]`、また`len(nums)`とする。見慣れたアクセスの仕方なので、読むのに苦労しない、ように思う。

# Step 3

PRを作り終えて、見直してから気づいたのだが、`total == 0`の場合の処理が`total < 0` や `total > 0`の場合と比べると複雑で、このブロックこそネストを浅くしたいなと思った。leftとrightの操作も対照に見えやすく、読みやすい。

```
if total < 0:
    left += 1
    continue

if total > 0:
    right -= 1
    continue

# total == 0 の時の処理
```

# Feedback (私の解釈を含む)

- 基本的に入力を変更しない方がいい。変更する場合はコメントで明記。
- 二重ループで外側のインデックスだけを`fixed_*`としてしまったのは意図が読み取れず、そもそも見ない形。普通に`i`, `j`か、もし外側を`fixed_*`で行くなら内側は`moving_*`としないと対応関係が不明瞭、のように思う。
