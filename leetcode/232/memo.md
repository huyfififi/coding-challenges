# Step 1

FILOのStack一つだけでFIFOのQueueを実装できるとは思えないので、Stackを二つ使用することを考えた。In hindsight, 問題のタイトルが「Implement Queue using Stacks」とStackが複数形だったので、複数のStackを用いることは仄めかされていた。

2つのStackを用意し、片方の底をQueueの先頭、もう片方の底をQueueの末尾とすればうまくいきそう。

Queue: [1, 2, 3, 4]

| 4 |
| 3 |
| 2 |
| 1 |  |   |
|___|  |___|

Queueの末尾にPushの時は全ての要素をQueueの先頭側に寄せて、その上に乗せる。

                    | 5 |
| 4 |               | 4 |
| 3 |               | 3 |
| 2 |               | 2 |
| 1 |  |   |        | 1 |   |   |
|___|  |___|   ->   |___|   |___|

Queueの先頭からPopする時は、全ての要素をQueueの末尾側に移して、そこから値を取る。

        | 1 |
        | 2 |               | 2 |
        | 3 |               | 3 |
        | 4 |               | 4 |
|   |   | 5 |       |   |   | 5 |
|___|   |___|   ->  |___|   |___|

push か (pop または peek) が連続して呼ばれているとき、Stack内の要素の移し替えが発生せず、どちらかの一番上にアクセスするだけで良いので O(1)。
逆に、pushの次に (pop または peek)か呼ばれるとき (また、pop/peekの次にpushの場合)、仮想Queue内要素数(nとする)分移し替えが発生するので、O(n)。

償却計算量の分析として、n回の操作のうち、最初の(n-a)回はO(1)で、残りのa回はO(n)の操作が必要だと見積もると、総操作回数はだいたい

(n - a) * 1 + a * n = n - a + a * n

n回の操作の平均を取ると

(n - a + a * n) / n = 1 - a/n + a

aが定数の場合、この式は定数に収束するため、償却計算量はO(1)となる。
aがnに対して無視できない大きさ（例えばa = n/2など）の場合、償却計算量はO(n)となる。

償却計算量の見積もりをどのように展開すれば良いのかわからないので、他の方々のPRを見ることにする。

迷ったところは、二つのStackの命名で、どういう変数名がわかりやすいか少し考えてみたけれど、良い案が思い浮かばなかった。

## 別解 (`step1_b.py`)

少しChatGPTとやりとりしてみると、Queueを

Queue: [1, 2, 3, 4]

input   output

| 4 |   | 1 |
| 3 |   | 2 |
|___|   |___|

と表現する方法なら、私の方法よりも少ない操作回数で同じメソッドを実装できるよう。
実装してみると、確かに、peek/popにおいてoutputに使用するStackが空だった場合のみ移し替えが発生するので、操作の回数がかなり省けている。
このメモを書いている時点では、私の方法の方がQueueが今どのような状況なのか説明しやすく直感的にわかりやすいと思うが、少し脳内で寝かせてみることにする。