# Step 1

2つの方法が思いついた。

## Two-pass

まずは左上から右下に0 (からの距離) を波及させて、その後右下から左上に0 (からの距離) を波及させる方法。
数年前に友人と勉強会をした時、似たような問題 (かどうかは定かではないが) を友人がこの方法で解いているのを隣で見て、確かにうまく行きそうだな、こんな方法あるのかと思った記憶がある。

時間計算量: O(mn)
空間計算量: O(1) (とりあえず入力を変更してしまう形で実装した。)

## Loop + BFS

シンプルに、各0から最短距離を波及させていく方法もあるな、と思ったが、この方法の時間計算量はO(mn)より大きくなりそうなのでTLEだろう。

一応書いて走らせてみたが、案の定TLEだった。-> `step1_brute_force_recursion_tle.py`

時間計算量: O((mn) ^ 2)? 0が取り得る個数は`mn`、本当は早めにreturnしているが、それがなかったとするとmatrix内の全てに最短距離を波及させていくので`mn`、よって`mn * mn`だが、実際のところどうなのだろう...。
空間計算量: O(mn) 新しく作るmatrixの大きさが`mn`、左上の0から再帰関数を呼んで右下まで行くと`m + n`で、これがcall stackの最大長。O(mn) + O(m + n) = O(mn)

TODO: Check if it is possible to confirm the time complexity
