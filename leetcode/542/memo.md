# Step 1

2つの方法が思いついた。

## Two-pass (`step1_two_pass.py`)

まずは左上から右下に0 (からの距離) を波及させて、その後右下から左上に0 (からの距離) を波及させる方法。
数年前に友人と勉強会をした時、似たような問題 (かどうかは定かではないが) を友人がこの方法で解いているのを隣で見て、確かにうまく行きそうだな、こんな方法あるのかと思った記憶がある。

時間計算量: O(mn)
空間計算量: O(1) (とりあえず、入力を変更してしまう形で実装した。)

## Loop + DFS

シンプルに、各0から最短距離を最後まで波及させていく方法もあるな、と思ったが、この方法の時間計算量はO(mn)よりかなり大きくなりそうなのでTLEだろう。時間計算量はこの時点ではよくわからなかった。

一応書いて走らせてみたが、案の定TLEだった。-> `step1_brute_force_recursion_tle.py`

時間計算量: O((mn)^2)?, 0が取り得る個数は`mn`、本当は早めにreturnしているが、それがなかったとするとmatrix内の全てに最短距離を波及させていくので`mn`。よってかなり多めに見積もるとO((mn)^2)だが、実際のところどうなのだろう...。

手元の環境で試してみた。各入力に対して10回関数を呼んだ際の実行時間を計測している。

1. [[1, 0], [1, 0], [1, 0], ...] (n = 2)

テストケースでTLEになったもの。右上の0から順に、それぞれ左下の1まで最小値を拡散させていくので、同じセルを何度も更新してしまう。

| mn (n = 2) | (mn)^2    | s (time taken)  | s / ((mn)^2)      |
| ---------- | --------- | --------------- | ----------------- |
| 4          | 16        | 0.0004391670227 | 0.00002744793892  |
| 16         | 256       | 0.001873016357  | 0.000007316470146 |
| 200        | 40000     | 0.1182088852    | 0.00000295522213  |
| 1000       | 1000000   | 3.642772913     | 0.000003642772913 |
| 3000       | 9000000   | 35.14230704     | 0.000003904700783 |
| 5000       | 25000000  | 98.57335901     | 0.000003942934361 |
| 8000       | 64000000  | 254.4024489     | 0.000003975038264 |
| 10000      | 100000000 | 398.5889831     | 0.000003985889831 |

2. n = m (正方形) で、右下以外のセルが全て1

| m   | (mn)^2 (= m^4) | s (time taken)  | s / ((mn)^2 = m^4) |
| --- | -------------- | --------------- | ------------------ |
| 5   | 625            | 0.0004339218139 | 0.0000006942749023 |
| 10  | 10000          | 0.005936145782  | 0.0000005936145782 |
| 20  | 160000         | 0.1049950123    | 0.0000006562188268 |
| 30  | 810000         | 0.5900979042    | 0.0000007285159311 |
| 40  | 2560000        | 1.969274044     | 0.0000007692476735 |
| 50  | 6250000        | 4.846431017     | 0.0000007754289627 |
| 60  | 12960000       | 12.39739203     | 0.0000009565888916 |
| 70  | 24010000       | 19.19709587     | 0.0000007995458505 |
| 80  | 40960000       | 32.39733386     | 0.0000007909505337 |
| 90  | 65610000       | 51.98664021     | 0.0000007923584852 |
| 100 | 100000000      | 79.64984798     | 0.0000007964984798 |
| 110 | 146410000      | 116.3433583     | 0.0000007946407915 |
| 120 | 207360000      | 167.361892      | 0.0000008071078896 |
| 130 | 285610000      | 231.9947789     | 0.0000008122782076 |
| 140 | 384160000      | 313.3389368     | 0.0000008156469617 |
| 150 | 506250000      | 412.2144761     | 0.0000008142508170 |
| 160 | 655360000      | 534.8270509     | 0.0000008160813155 |

(実行時間) / ((mn)^2) をみると、なんとなく増加傾向にあるように感じるものの、ほぼ一定であるように感じるので、(実行時間) = (係数) * (mn)^2 ではないかと予想するが、あまり自信はない。

数日悩んだりLLMと対話してみたが、私の解法の時間計算量を他の人に説明できるくらい理解するに至らなかった。一旦、PRを出してみようと思う。

空間計算量: O(mn) 新しく作るmatrixの大きさが`mn`、左上の0から再帰関数を呼んで右下まで行くと`m + n - 2`で、これがcall stackの最大長。O(mn) + O(m + n) = O(mn)

## BFS

しばらく他の解法が思いつかなかったので、ChatGPTに最低限のヒントを、とお願いしたところ、call stackではなくqueueを使いなさい、と言われたので、なるほど、各0において最短距離の更新を終わらせてから次の0を処理するのではなく、全ての0から少しずつ処理した範囲を広げていけば、同じセルを何度も更新せずに済むのか、と気づいた。

時間計算量: O(mn), 最初のループ・deep copyがO(mn)。BFSの処理もO(mn): あるセルの最小値が`inf`から更新されたら、それ以降の訪問はそれ以上の値しかあり得ないので、一つのセルは二度値を更新・隣あうセルをQueueに追加することがない。一つのセルは最大でも4回しか訪問されないためO(mn)。
空間計算量: O(mn), 最初に入力matrixのコピーを作成している。入力を変更する形にしたとしても、全てのセルが0の場合、queueに全てのセル (\*4) を追加することになり、最悪メモリ使用量は`mn`に比例する。

# Step 2

一社Discord内に先駆者が見つからなかったので、LeetCodeのSolutionsを眺めてみる。

私はqueueに「最短距離未更新のセル」を入れていたが、ぱっと眺めてみると、全ての解法が、queueに「最短距離更新済みのセル」を入れていた (-> `step2.py`)。確かにこれなら、`while`文に入る前にqueueにセルを入れる操作が簡単になっているし、queueに追加されるセルの数も抑えられる。

queueに何を入れるのか約束できている限り、範囲チェックを後でやる方法でも、LeetCodeのSolutions（や、一社内のPR）でよくみられる、範囲チェックを先にやる方法でも、どちらでも良さそうだ。今回の場合は範囲チェックを先にやる方法の方がやや読みやすくまとまるように思う。

## 迷ったところ

- 自分なりに回答を整形する時に少し悩んだのは、`while`の中のif文に二つの条件 (範囲チェック・最小値を更新できるか確認) が入っているところだった。これくらいの複雑さであれば問題ないように思いつつ、二つの条件分岐に分解した方がやや冗長だがわかりやすい、だろうか？
- 入力リストを変更する形になっているが、入力とは別のコピーを用意するのは難しくなく、面接という設定なら一言添えれば良い些細なことのように感じるので、一旦このまま進む。
- `directions`は関数内でしか使われないので、クラスやモジュールのconstantにしてしまうと、余計な情報を関数外に出してしまうように思う。なので、関数内に留めた。
    - そもそも、これくらいの大きさのiterableだったらわざわざ変数を置かなくてもいいかも。

# Stpe 4

野田さんに提示していただいた方法もPythonで書いてみた (`step4.py`)。49/50のテストケースでTLEとなるが、DFSよりも高速そう、DFSのアプローチは42/50でTLEとなったので。

時間計算量: O((m + n)mn)?
空間計算量: O(mn)

`row_update`, `col_update`は意図が伝わりづらいとのフィードバックも。
