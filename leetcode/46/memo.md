# Step 1

うまく関数呼び出し間で同じオブジェクトを共有してコピーを防ぐことができないか少し考え、remainingの方をうまく処理する方法を思いつかなかったので (この時点では、i番目へのアクセスがあり結局走査が必要ならコピーを作っても別にいいか、と考えた)、素直に各呼び出しでコピーを作成して渡す方法を実装した。

`n = len(nums)`として、関数呼び出しを木と見立てた時rootの下にn個の子ができる。それぞれ(n-1)個の子を持つので、深さ2のnodeの数はn * (n - 1)
1 + n + n (n - 1) + n * (n - 1) * (n - 2) + ... + n!
nが大きいとき、最後の項が支配的なのでO(n!)
それとは別に、各関数呼び出しで合計の長さnのlistを二つ新しく作っているので、総じて O(n * n!)

空間計算量は関数呼び出しの深さが最大n、また各関数呼び出しにおいて長さnの新しいlistを作り保持するので、総じてO(n^2)
出力も含めると、長さnのpermutation n!通り全て保存するので O(n * n!) だが、出力ってspace complexityを出す時に入れるんだったっけ...

numsの長さが最大でも6なので、`6 * 6!` = 4320 くらいのオーダーの処理が必要になるが、これは Python が一秒間に大体10^6 個くらいの処理を行えるとすると、十分に小さな実行時間で収まる。

# Step 2

他の方々のPRを見て、確かに、pop()しても時間計算量は変わらないがコピーが減らせるのは嬉しいな、と思った。

`generating`はあまり見ない名付けなので、`prefix`とされている方を見てわかりやすかったので真似した。
