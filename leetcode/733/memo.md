# Step 1

副作用がない形にすると `image`をコピーしないといけないので時間・計算ともに O(m * n)かかってしまう。副作用があってもいい、と仮定しておく。

事前に指摘されていたので、queueやcall stackに積む数を減らすために、新しい要素をqueue・call stackに入れる前に`visited`のフラグを立てておく（今回の場合色を先に塗り替えておく）ことを心がけた。結果的に、意識していなかったが、DFSでの無限ループを防ぐことができた（関数呼び出しの後に色を塗るようにすると無限の関数呼び出しに陥る）。

上下左右のマスに移動する条件分岐がやや見辛いが、改善案は思いつかなかった。

後から考えたら、`m` -> `height`, `n` -> `width`とした方が、変数が何を意味するのかわかりやすくなるかなと思ったが、`m`、`n`も`i`、`j`同様に広く使われているから気にしすぎなのか、とも考えた。

# Step 2

[NobukiFukuiさん](https://github.com/NobukiFukui/Grind75-ProgrammingTraining/pull/15)
	- 範囲チェックを呼び出し後にやる方法もある。
	- directionを示すリストを作ってループを回す方法は、if文を並べるのとどっちが人気なのだろうか。
	- `nrows`, `ncols` (number of rows, number of cols)という変数の命名、わかりやすいなと思った。
[Kitaken0107さん](https://github.com/Kitaken0107/GrindEasy/pull/12)
	- `dfs`という関数名は避けるべきとの指摘。
	- 関数を呼び出した後に判定するタイプの解法。
[colorboxさん](https://github.com/colorbox/leetcode/pull/11)
	- 最終的には、同じく四方向のdirectionを定義して呼び出し後に弾く方法。
	- `to_color`だけではなくて`from_color`も引数にする方法は思いつかなかった。

`k`を塗り替えるマスだとする。再帰関数を呼ぶ前に範囲チェックする方法では、塗りつぶすマスに対してだけ関数が呼び出されるから関数呼び出しの回数は`k`回。再帰関数を呼んでから範囲チェックする方法では、塗り替えるマスに対して4回の関数呼び出しが発生するので合計`4k`の関数呼び出しが発生する。
計算量自体は変わらず、BFSだと呼び出し後にチェックする方法の方が簡潔で読みやすく感じた。DFSはsourceの色をトラックする必要があるのでhelper関数が必要になるが、シンプルな操作に留まるのでこちらもわかりやすくなりそう。

directions + for loopは、個人的に冗長に書き下す方法よりも（誤差レベルだが）わかりにくく感じる。同じ行を繰り返し書くことを嫌がる方もいるだろうし、そこはフィードバック次第で柔軟にやっていこうと思う。
